- JavaScript가 Primitive Type과 Object/Reference Type 을 구분하는 이유는 이 둘이 근본적으로 다르기 때문이다

  - 원시 타입의 값은 Immutable하지만 객체는 Mutable한 값이다.
  - 원시값을 변수에 할당하면 변수가 확보한 메모리의 공간에는 실제의 값이 저장된다. 하지만 객체를 변수에 할당하면 변수가 확보한 메모리 공간에 해당 객체의 주소, 즉 참조값이 저장된다.
  - 원시값을 갖는 변수를 다른 변수에 할당하면 원시 값이 복사되고 이를 pass by value라고 칭한다
  - 객체를 가리키는 변수를 다를 변수에 할당하면 참조값이 복사될 뿐이므로 이를 pass by reference라고 한다.

- 원시값이 Immutable 하다는 말이 무엇일까?

  - 실제로 변수에 다른 값을 대입할 수 있는데도 Immutable하다는게 무슨 말인지 헷갈릴 수 있다. 이때 변수와 값에 대해서 구분해서 생각할 필요가 있다.
  - `변수`: 값을 저장하기위해 확보한 메모리 공간 자체나, 그 메모리 공간을 `식별하기 위한 이름`
  - `값`: 변수에 저장된 데이터로 표현식이 평가되어 생성된 결과로, Immutable한 것은 이 값이다.
  - 이때 엄밀히 말하면 변수에는 값이 전달되는 것이 아니라, 값이 저장된 곳의 메모리 주소가 전달된다. 그래서 변수같은 식별자는 값이 아니라 해당 Immutable한 값이 저장된 곳의 주소를 기억한다.

- 객체
  - 객체는 프로퍼티의 갯수가 정해져있지 않고 동적으로 추가되고 삭제 가능하고, 프로퍼티의 값 또한 제약이 없어서 원시 값처럼 메모리 공간의 크기를 사전에 정의하는것이 어렵다.
  - 객체의 값이 변경가능하다는 것은 실제 객체 데이터가 저장된 곳 주소가 저장된 변수는 `시작주소 reference value`를 가지고 있고, 이 `reference value`를 변경하지 않고도 객체의 값을 변경할 수 있다는 말이다.
  - 이때 객체를 복사할때, 이 `reference value`를 복사하게 되어 여러 변수가 실제로는 하나의 객체 데이터에 접근할 수 있어 문제가 발생할 수 있다.

#### 함수

- 함수는 자바스크립트에서 가장 중요한 핵심 개념
  - `스코프, 실행 컨텍스트, 클로저, 생성자 함수에 의한 객체 생성, 메서드, this, 프로토타입, 모듈화` 등이 모두 함수와 관련이 있다.
  - 자바스크립트의 함수는 객체 타입의 값이다
    - 숫자 값을 숫자 리터럴로 생성하는 것처럼 함수리터럴은 function 키워드/함수이름/매개변수/함수 몸체로 구성가능하다
    - 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.
    - 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다
    - 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백함수라고 하고, 매개 변수를 통해 함수의 외부에서 콜백함수를 전달받은 함수를 고차 함수(High order Function)라고 한다.
    - `순수 함수` 동일한 이수가 전달되면 언제나 동일한 값을 반환하는 함수
    - `비순수 함수` 함수의 외부 상태에 따라 반환값이 달라지는 함수, side effect(부수효과)를 가진다

# 스코프

- 스코프란? 모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효범위가 결정되는데 이를 스코프라고 한다. 네임스페이스이다.

- 함수 몸체 내부는 지역 스코프를 만든다. 지역 변수는 자신의 지역스코프와 하위 지역 스코프에서 유효하다.

  - 함수는 중첩 될 수 있으므로, 함수의 지역 스코프도 중첩되고 계층적인 구조를 가진다.
  - 이렇게 스코프가 계층적으로 연결된 것을 스코프 체인이라고 한다.
  - 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작해서 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.
  - 상위 스코프에서 유효한 변수는 하위스코프에서 스코프 체인을 통해서 접근할 수 있지만, 구조적으로 상위 스코프에서는 하위 스코프의 변수에 접근할 수 없다.

- 함수 레벨 스코프

  - 함수에 의해 생기는 지역스코프를 말한다.
  - 대부분의 언어는 if, while 블럭 등도 지역 스코프를 만드는데 이를 `블록 레벨 스코프`라고 한다. 하지만 `var` 키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정하는데, 이를 `함수 레벨 스코프`라고 한다.
  - ES6에서 도입된 `let, const` 키워드는 `블록 레벨 스코프`를 지원한다.

- 자바스크립트는 렉시컬 스코프를 따른다
  - 함수를 어디에서 호출한지가 아니라 `어디에서 정의했는지에 따라 상위 스코프를 결정한다`

# 전역 변수의 문제점

- `변수의 생명 주기`

  - 메모리 공간이 확보된 시점부터 메모리 공간이 헤제되어 가용메모리풀에 반환되는 시점까지
  - 할당된 메모리 공간은 더 이상 누구도 참조하지 않을때 가비지 콜렉터에 의해 해제되어 가용 메모리 풀에 반환된다.

- 전역 변수의 문제점

  - 암묵적 결합
    - 모든 코드가 전역 변수를 참조하고 변경할 수 있는 것을 암묵적 결합잉라고 하는데, 이를 허용하는 것은 의도치 않게 상태가 변경되는 경우가 생긴다
  - 긴 생명주기
    - 전역 변수는 생명 주기가 길어 메모리 리소스도 오랜기간 소비하는 문제가 있고, var 키워드를 사용한 경우 중복선언을 허용해서, 의도치않게 재할당이 이뤄져 디버깅이 어렵다.
  - 스코프 체인상에서 종점에 존재
    - 전역 변수는 스코프 체인상에서 종점에 존재하기 때문에 검색속도가 제일 느리다
  - 네임스페이스 오염
    - 자바스크립트는 파일이 분리되어있다해도 하나의 전역 스코프를 공유한다. 그래서 다른 파일내에서 동일한 이름의 전역 변수가 있다면 재할당하거나 하는 등의 문제가 생길 수 있다.

- 전역 변수의 사용을 억제하는 방법
  - 전역 변수를 반드시 사용해야할 이유가 없다면 지역변수를 사용해야하고, 변수의 스코프는 최대한 작게 만든다.

## let, const 키워드와 블록 레벨 스코프

- `var`의 문제점

  - 변수가 중복 선언된다

  ```javascript
  var x = 1;
  var y = 1;
  var x = 100; // var키워드가 없는 것처럼 동작
  var y; // 무시
  ```

  - 함수레벨 스코프로 동작해서 블록내에서 `var`키워드로 변수를 선언하면 블록 밖에서도 접근이 가능하다.
  - 호이스팅이 됬을때 변수 선언문 이전에 참조할 수 있다.

  ```javascript
  // 호이스팅이 일어났고, undefined로 초기화된다
  console.log(foo);
  foo = 123;
  console.log(foo); // 123출력
  var foo; // 호이스팅 된다
  ```

  이렇게 되면 오류가 발생할 여지가 많고 가독성이 좋지 않다.

- `let`

  - 변수를 중복 선언하면 문법 에러(SyntaxError)를 발생시킨다
  - 블록 레벨 스코프를 따른다.

  ```javascript
  let foo = 1;

  {
    let foo = 2; // let 키워드는 블록 레벨 스코프를 지원하므로 이 스코프 내에서는 foo 변수를 새로 선언해도 syntax error를 발생시키지 않는다
    let bar = 3; // bar 변수는 이 블록 스코프내에 존재한다.
  }

  console.log(bar); // reference error를 발생 시킨다.
  ```

- `const`

  - `var` 또는 `let` 키워드로 선언한 변수는 재할당이 자유로운데, `const`는 재할당이 안된다
  - `const`키워드로 선언된 변수에 원시값(primitive value)를 할당한 경우 원시값이 Immutable하고, const 키워드에 의해 재할당이 금지 되기 때문에 할당한 값을 바꿀수 없다.
  - `const`키워드와 객체
    - const 키워드로 선언된 변수에 개게를 할당한 경우, 값을 변경할 수 있다.
    - const 키워드는 재할당을 금지할 뿐, 불변하다는 의미는 아니다
    - 객체에서는 값을 변경한다고 `변수에 할당한 참조값이 변하지 않으므로` 프로퍼티 생성, 삭제, 값 변경등은 언제든지 가능하다

- 변수를 선언할때 일단 `const` 키워드를 사용하고, 반드시 재할당이 필요한 경우(그리고 진짜 재할당을 해야하는지 고민해보고) `let` 키워드로 변경하자
